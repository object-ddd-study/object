# 설계 품질과 트레이드오프

# 내용 요약
- 객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동 
	- 이를 위한 중요한 원칙 중 하나는 객체의 상태가 아니라 행동에 초점을 맞추는 것

## 데이터 중심의 영화 예매 시스템 (안 좋은 예시)

- 데이터 중심 설계
	- 객체는 자신이 포함하고 있는 데이터를 조작하는데 필요한 오퍼레이션 정의
	- 상태(구현)에 관한 세부사항이 객체의 인터페이스에 스며들게 되어 캡슐화 원칙이 무너진다. 
- 책임 중심 설계
	- 객체는 다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태를 보관
- 객체의 상태는 구현에 속한다. 
- 객체의 책임은 인터페이스에 속한다. 


## 설계 트레이드오프
- 객체지향에서 좋은 설계의 특징을 판단할 수 있는 기준 세가지
	- 캡슐화
	- 응집성
	- 결합도
- 캡슐화의 정도가 응집도, 결합도에 영향을 미친다.

### 캡슐화
- 변경 가능성이 높은 부분(**구현**)은 내부에 숨기고 외부에는 상대적으로 안정적인 부분(**인터페이스**)만 공개함으로써 변경의 여파를 최소화

### 응집도
- 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도
- 요구 사항이 변경되었을 때 몇 개 모듈을 수정해야 하는지

### 결합도
- 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도
- 어느 한 모듈을 변경했을 때 함께 변경해야 하는 모듈이 얼마나 되는지

## 데이터 중심 영화 예매 시스템의 문제점
- 캡슐화를 위반하기 때문에 응집도가 낮고, 결합도는 높다.

### 캡슐화 위반

- 접근자, 수정자 메서드는 객체 내부의 상태에 대한 어떤 정보도 캡슐화하지 못한다.
- 접근자와 수정자에 과도하게 의존하는 설계 방식 : 추측에 의한 설계 전략 (안티패턴)

### 높은 결합도
- e.g. `Money.Fee` 타입 변경시 `ReservationAgency` 변경 필수 
- 시스템 내 어떤 변경도 `ReservationAgency` 변경 유발
### 낮은 응집도
- 서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존
	- e.g. 새로운 할인 정책, 할인 조건이 추가될 경우 하나 이상의 클래스 추가 필요
- 단일 책임 원칙
	- 클래스는 단 한가지의 변경 이유만 가져야 함

## 자율적인 객체를 향해
### 캡슐화를 위한 개선 (step2)
- 객체는 단순한 데이터 제공자가 아니다. 데이터보다 협력에 참여하면서 수행할 책임을 정의할 오퍼레이션이 더 중요하다.
- 객체를 설계할 때 다음 두 개의 질문을 고민하자.
	- 이 객체가 어떤 데이터를 포함해야 하는가?
	- 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?

## 여전히 부족하다
- 개선된 코드에서 객체들은 자신의 데이터를 스스로 처리하고 있긴 하지만 여전히 내부 구현 정보를 외부로 노출하고 있다. (캡슐화 위반)
- e.g. `DiscountCondition.isDiscountable(DayOfWeek dayOfWeek, LocalTime time)`
- e.g. `Movie.calculatePercentDiscountedFee()`, `Movie.calculateAmountDiscountedFee()`

### 여전히 높은 결합도
- e.g. DiscountCondition 종류가 추가될 경우 Movie 안에 있는 if-else 코드 수정 필요

### 여전히 낮은 응집도
- e.g. 할인 조건의 종류가 변경될 경우 `DiscountCondition`, `Movie`, `Screening` 수정 필요 

## 데이터 중심 설계의 문제점
- 너무 이른 시기에 데이터에 대해 결정하도록 강요
	- 데이터는 구현의 일부다. 데이터 중심 설계를 하면 너무 이른 시기에 내부 구현에 초점을 맞추게 된다. (절차적 프로그래밍)
	- 데이터에 관한 지식이 객체의 인터페이스에 고스란히 드러나게 된다. -> 변경에 취약해짐 
- 협력이라는 문맥을 고려하지 않고, 객체를 고립시킨 채 오퍼레이션 결정
	- 객체 지향 설계의 무게중심은 객체의 내부가 아닌 외부에 맞춰져 있어야 한다. 중요한 것은 상태가 아니라, 객체가 다른 객체와 협력하는 방법(행동)이다.

---
# 템플릿 정리

## 마음에 드는 문장 또는 중요하다고 생각한내용 
- 책임 중심의 설계가 '책임이 무엇인가'를 묻는 것으로 시작한다면, 데이터 중심의 설계는 객체가 내부에 저장해야 하는 '데이터가 무엇인가' 를 묻는 것으로 시작한다.
- '이 객체가 포함해야 하는 데이터는 무엇인가?' 객체의 책임을 결정하기 전에 이런 질문의 반복에 휩쓸려 있다면 데이터 중심 설계에 매몰되어 있을 확률이 높다. 


## 이야기 해보고 싶은 내용
- 그렇다면 getter, setter 를 없애거나 private 으로 두는 게 최선?
- 새로운 어플리케이션을 설계한다면 어느 것부터 설계를 시작하시는지?
## 자신과 생각이 다른 내용
